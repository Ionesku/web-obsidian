---
title: Технические детали системы поиска
tags: [документация, поиск, технические]
created: 2025-10-25
---

# Технические детали системы поиска

Для тех, кто хочет понять, как работает система под капотом.

## 🏗️ Архитектура

### Двухслойная система

```
┌─────────────────────────────────────┐
│  Парсер запросов                    │
│  (Query Parser)                     │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│  Планировщик запросов               │
│  (Query Planner)                    │
└──────────────┬──────────────────────┘
               │
       ┌───────┴───────┐
       ▼               ▼
┌─────────────┐ ┌─────────────┐
│  Слой A     │ │  Слой B     │
│ (Локально)  │ │ (Сервер)    │
│             │ │             │
│ IndexedDB   │ │ Whoosh      │
│ < 50ms      │ │ < 200ms     │
└──────┬──────┘ └──────┬──────┘
       │               │
       └───────┬───────┘
               ▼
┌─────────────────────────────────────┐
│  Федератор                          │
│  (Federation)                       │
└──────────────┬──────────────────────┘
               │
               ▼
         Результаты
```

### Слой A - Локальный (IndexedDB)

**Что хранится:**
- Метаданные файлов (путь, имя, размер, mtime, hash)
- Теги (с иерархией)
- Свойства (frontmatter)
- Заголовки (H1-H6)
- Ссылки (wikilinks и markdown)
- Обратные ссылки
- Блоки (^block-id)
- Задачи (- [ ] / - [x])

**Структура IndexedDB:**
```javascript
{
  files: 'path, mtime, size, hash, name',
  meta: 'path, *tags, *headingTexts, *linkPaths',
  tagIndex: '[tag+path], tag, path',
  propIndex: '[key+value+path], key, value, path',
  linkIndex: '[dstPath+srcPath], dstPath, srcPath',
  blocks: '[path+blockId], path, blockId',
  tasks: '[path+line], path, done'
}
```

**Операции (O-нотация):**
- `pathsByTag(tag)` → O(1) - индексированный доступ
- `pathsByProp(key, value)` → O(1)
- `pathsByFile(name)` → O(n) - сканирование, но быстрое
- Boolean algebra (AND/OR/NOT) → O(k), k = размер множества

### Слой B - Серверный (Whoosh)

**Схема Whoosh:**
```python
{
    'path': ID(stored=True, unique=True),
    'name': TEXT(field_boost=2.0),
    'tags': KEYWORD(commas=True),
    'props': KEYWORD(commas=True),
    'content': TEXT(analyzer=StemmingAnalyzer),
    'tri': NGRAM(minsize=3, maxsize=3),  # для regex
    'mtime': DATETIME(),
    'size': NUMERIC()
}
```

**Scoring:** BM25F (лучше чем TF-IDF)

**Оптимизации:**
- AsyncWriter для индексации
- Trigram prefiltering для regex
- Path filtering через Whoosh filter (не post-processing)

## ⚡ Производительность

### Бенчмарки

| Операция | Локально | Сервер | Примечание |
|----------|----------|--------|------------|
| Индексация 1000 файлов | 1 сек | 2 сек | Батчинг |
| Поиск `tag:work` | < 10ms | N/A | IndexedDB |
| Поиск `"фраза"` | N/A | < 100ms | Whoosh |
| Комбо `tag:work "фраза"` | < 150ms | - | Федерация |

### Размеры индексов

| Количество файлов | IndexedDB | Whoosh | Всего |
|-------------------|-----------|--------|-------|
| 100 | 0.5 MB | 5 MB | 5.5 MB |
| 1,000 | 3 MB | 30 MB | 33 MB |
| 10,000 | 25 MB | 250 MB | 275 MB |

### Оптимизации

**1. Дедупликация по hash:**
```typescript
const hash = hashContent(content);
if (existingFile.hash === hash) {
  return; // Не переиндексируем
}
```

**2. Батчинг:**
```typescript
const BATCH_SIZE = 50;
while (queue.length > 0) {
  const batch = queue.splice(0, BATCH_SIZE);
  await indexBatch(batch);
  await yield(); // Отдаем управление UI
}
```

**3. Web Worker:**
```typescript
// Парсинг в фоне, не блокирует UI
worker.postMessage({ type: 'INDEX_FILE', payload: {...} });
```

**4. Префильтрация:**
```python
# Regex с триграммами
if pattern.startswith('TODO'):
    tri_query = Term("tri", "TOD")
    clauses.append(tri_query)
```

## 🧩 Парсер запросов

### Грамматика (EBNF-подобная)

```
query       = or_expr
or_expr     = and_expr ("OR" and_expr)*
and_expr    = not_expr not_expr*
not_expr    = "-" primary | primary
primary     = "(" or_expr ")" | term

term        = phrase | regex | property | prefix_op | word
phrase      = '"' .* '"'
regex       = '/' .* '/' [flags]
property    = '[' key op value ']'
prefix_op   = prefix ':' value

prefix      = "tag" | "file" | "path" | "block" | "section" 
            | "link" | "backlink" | "task" | "line"
op          = ':' | '=' | '!=' | '>' | '>=' | '<' | '<='
```

### AST (Abstract Syntax Tree)

```typescript
type Expr = 
  | { kind: 'and'; children: Expr[] }
  | { kind: 'or'; children: Expr[] }
  | { kind: 'not'; child: Expr }
  | Term

type Term = 
  | { kind: 'word'; value: string }
  | { kind: 'phrase'; value: string }
  | { kind: 'tag'; value: string }
  | { kind: 'prop'; key: string; op: string; value: any }
  // ... и т.д.
```

### Планирование

**Классификация термов:**
```typescript
function classifyTerm(term: Term): 'local' | 'server' | 'hybrid' {
  switch (term.kind) {
    case 'tag':
    case 'file':
    case 'path':
    case 'prop':
    case 'block':
    case 'section':
    case 'link':
    case 'backlink':
    case 'task':
      return 'local';
    
    case 'word':
    case 'phrase':
    case 'regex':
      return 'server';
    
    case 'line':
      return 'hybrid';
  }
}
```

**Разделение на слои:**
```typescript
// tag:work "important" 
// ↓
// Local: tag:work
// Server: "important"
// Execution: filter by tag, then search in filtered files
```

## 🔄 Процесс индексации

### Frontend (IndexedDB)

1. **Сохранение файла:**
```typescript
await api.saveFile(path, content);
```

2. **PostMessage в Worker:**
```typescript
worker.postMessage({
  type: 'INDEX_FILE',
  payload: { path, content, mtime, hash }
});
```

3. **Парсинг в Worker:**
```typescript
const meta = parseMarkdown(path, content);
// Извлекает: tags, props, headings, links, blocks, tasks
```

4. **Запись в IndexedDB:**
```typescript
await db.transaction('rw', [...tables], async () => {
  // Атомарно обновляем все индексы
});
```

### Backend (Whoosh)

1. **Webhook от frontend (опционально):**
```http
POST /api/search/index
{
  "path": "notes/work.md",
  "content": "...",
  "name": "work.md",
  "tags": ["work"],
  "props": {"status": "active"}
}
```

2. **Индексация:**
```python
writer = AsyncWriter(ix)
writer.update_document(
    path=path,
    content=content,
    tags=",".join(tags),
    # ...
)
writer.commit()
```

## 🔍 Процесс поиска

### Пример: `tag:work "important"`

**1. Парсинг:**
```typescript
const ast = parseQuery('tag:work "important"');
// {
//   kind: 'and',
//   children: [
//     { kind: 'tag', value: 'work' },
//     { kind: 'phrase', value: 'important' }
//   ]
// }
```

**2. Планирование:**
```typescript
const plan = planQuery(ast);
// {
//   local: { kind: 'tag', value: 'work' },
//   server: { kind: 'phrase', value: 'important' },
//   explanation: 'Query uses both local filters and server search'
// }
```

**3. Исполнение локальной части:**
```typescript
const paths = await executeLocal(plan.local);
// Set<string> с путями файлов с тегом work
```

**4. Исполнение серверной части:**
```typescript
const serverReq = {
  terms: [{ type: 'phrase', value: 'important' }],
  restrict_paths: Array.from(paths)
};
const serverResp = await fetch('/api/search', { body: serverReq });
```

**5. Объединение результатов:**
```typescript
const hits = mergeHits(localHits, serverResp.hits);
```

## 🛠️ API Reference

### Frontend

```typescript
// Поиск
import { searchEngine } from '@/search/engine';

const result = await searchEngine.search(
  'tag:work "important"',
  { limit: 50, sort: 'mtime' }
);

// Индексация
await searchEngine.indexLocal({
  path: 'notes/work.md',
  content: '# Work\n...',
  mtime: Date.now(),
  hash: ''
});

// Статистика
const stats = await searchEngine.getStats();
// { files: 1234, tags: 567, links: 890, ... }
```

### Backend

```python
from app.search import get_indexer

# Индексация
indexer = get_indexer()
indexer.upsert_document(
    path='notes/work.md',
    content='# Work\n...',
    name='work.md',
    tags=['work', 'important'],
    props={'status': 'active'}
)

# Поиск (через HTTP API)
POST /api/search
{
  "terms": [{"type": "word", "value": "important"}],
  "restrict_paths": ["notes/work.md"],
  "limit": 50
}
```

## 🔐 Безопасность

### Изоляция пользователей

```python
# app/search/api.py
@router.post("/search")
async def search(
    req: SearchRequest,
    current_user: User = Depends(get_current_user)
):
    # Пользователь видит только свои файлы
    user_vault = get_vault_path(current_user.id)
    # ...
```

### Path validation

```python
def validate_path(path: str, user_vault: str) -> bool:
    real_path = os.path.realpath(os.path.join(user_vault, path))
    return real_path.startswith(user_vault)
```

### Rate limiting (TODO)

```python
from slowapi import Limiter

limiter = Limiter(key_func=get_remote_address)

@app.post("/search")
@limiter.limit("100/minute")
async def search(...):
    ...
```

## 📚 Дополнительные ресурсы

- [Whoosh Documentation](https://whoosh.readthedocs.io/)
- [IndexedDB API](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API)
- [Dexie.js](https://dexie.org/)
- [BM25 Algorithm](https://en.wikipedia.org/wiki/Okapi_BM25)

---

См. также:
- [[Введение в продвинутый поиск]]
- [[Операторы поиска]]
- [[Примеры запросов]]

